# PR #6: digest関数の最適化

- **ブランチ**: `feature/optimize-digest-function`
- **コミット**: `332078f`
- **PR**: [#6](https://github.com/liofval/Iscogram/pull/6)

## 背景

N+1クエリの解消後もベンチマーク結果にはタイムアウトが残っていました：

```
"リクエストがタイムアウトしました (POST /login)"
"リクエストがタイムアウトしました (POST /register)"
```

ログイン・登録処理のボトルネックを調査した結果、パスワードハッシュ計算に使用されている`digest`関数が問題であることが判明しました。

## 問題の分析

### 変更前のdigest関数

```php
function digest($src) {
    $src = escapeshellarg($src);
    return trim(`printf "%s" {$src} | openssl dgst -sha512 | sed 's/^.*= //'`);
}
```

この関数は**バッククオート演算子**（`` ` `` ）を使用してシェルコマンドを実行しています。

#### 実行されるプロセス

1ログインリクエストで以下が実行されます：

```
calculate_passhash($account_name, $password)
  └→ digest("{$password}:{$salt}")      ← 3プロセス生成
      └→ printf | openssl | sed
  └→ calculate_salt($account_name)
      └→ digest($account_name)          ← 3プロセス生成
          └→ printf | openssl | sed
```

**合計: 6つの外部プロセスを毎回生成**

### なぜ遅いのか

#### プロセス生成のコスト

外部プロセスの生成には以下のシステムコールが必要です：

1. `fork()` - 現在のプロセスをコピー
2. `exec()` - 新しいプログラムを読み込み・実行
3. パイプの作成とI/Oリダイレクト
4. プロセスの終了待ち

これらは**カーネルモードでの処理**であり、PHPのユーザースペース関数と比較して桁違いに遅いです。

#### 定量的な比較

| 方式 | 概算時間（1回あたり） | ログイン1回 |
|------|----------------------|------------|
| シェルコマンド（3プロセス） | ~5-10ms | ~10-20ms（2回呼び出し） |
| PHP `hash()` | ~0.01ms | ~0.02ms |
| **速度差** | **500〜1000倍** | |

ベンチマーカーがログイン・登録を並行して大量に実行するため、この差は非常に大きな影響を与えます。

## 解決方法

### 変更後のdigest関数

```php
function digest($src) {
    return hash('sha512', $src);
}
```

PHPの組み込み`hash()`関数を使用。OpenSSLライブラリを内部で利用しますが、プロセス生成は不要です。

### 変更の安全性

| 観点 | 説明 |
|------|------|
| ハッシュアルゴリズム | SHA-512 → SHA-512（同一） |
| 出力形式 | 16進数文字列（128文字）→ 同一 |
| 互換性 | 同じ入力に対して同じ出力を返す |

`openssl dgst -sha512`とPHPの`hash('sha512')`は、同じ入力に対して同じハッシュ値を返します。既存のデータとの互換性に問題はありません。

### 副次的な改善

1. **コマンドインジェクションリスクの排除**: シェルコマンド実行を廃止したことで、`escapeshellarg()`の処理も不要になり、コマンドインジェクションのリスクが根本的に排除されました

2. **コードの簡潔さ**: 3行から1行に削減。意図が明確なコードになりました

## 技術解説：PHP hash()関数

### hash()関数の仕組み

```php
string hash(string $algo, string $data, bool $binary = false)
```

- `$algo`: ハッシュアルゴリズム名（'sha512', 'sha256', 'md5' 等）
- `$data`: ハッシュ対象のデータ
- `$binary`: `true`で生のバイナリ、`false`（デフォルト）で16進文字列

PHPの`hash()`は内部でOpenSSLまたはlibsodiumのCライブラリを呼び出します。C言語の関数をPHPから直接呼び出すため、シェル経由のオーバーヘッドがありません。

### 利用可能なアルゴリズム一覧の確認

```php
print_r(hash_algos());
// ['md5', 'sha256', 'sha512', ...]
```

### パスワードハッシュについての補足

本アプリケーションでは`sha512`を使用していますが、実際のWebアプリケーションでは`password_hash()`（bcrypt/Argon2）の使用が推奨されます。SHA-512は高速すぎるため、ブルートフォース攻撃に対する耐性が低いためです。ただし、ISUCONでは既存のデータとの互換性が必要なため、アルゴリズムの変更は行いません。

## 効果

```
変更前: score=0      success=422    fail=26
変更後: score=29,742 success=28,625 fail=0  （PR #8のバグ修正含む）
```

## 学んだこと

1. **外部プロセス呼び出しは避ける**: PHPには多くの組み込み関数があり、シェルコマンドの代わりに使える場合がほとんど
2. **プロセス生成コストは大きい**: fork/execは高コストなシステムコールであり、リクエスト処理中に実行すべきではない
3. **標準ライブラリの活用**: 暗号関連の処理はPHPの`hash`拡張を使う方が安全で高速
4. **コマンドインジェクション対策**: そもそもシェルコマンドを実行しないことが最善の対策
